/*
 * Copyright (C) 2018 Volodymyr Kryachko
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef GRID2D_GRAPH_HPP
#define GRID2D_GRAPH_HPP

#include <boost/graph/relax.hpp>
#include <boost/graph/properties.hpp>
#include <boost/graph/graph_traits.hpp>

#include "g2dg_vertex_iterator.hpp"
#include "g2dg_out_edge_iterator.hpp"

#define NEED_PROPERTY_MAP
#define GRID2D_GRAPH_PARAMS typename row_type, typename column_type, \
                            row_type rows_num, column_type columns_num

#define GRID2D_GRAPH_DECLARATION g2dg::grid2d_graph<row_type, column_type, \
                                                    rows_num, columns_num>

namespace g2dg {

    template <typename Graph, typename Descriptor, typename Index>
    struct grid_graph_index_map;

    template <
        typename row_type, typename column_type,
        row_type rows_num, column_type columns_num>
    class grid2d_graph {
    public:
        typedef grid2d_graph<row_type,column_type,rows_num,columns_num> type;
        typedef row_type row_t;
        typedef column_type column_t;

        typedef typename boost::graph_traits< grid2d_graph<row_type,column_type,rows_num,columns_num> >::
            vertex_descriptor
            vertex_descriptor;
        typedef typename boost::graph_traits< grid2d_graph<row_type,column_type,rows_num,columns_num> >::
            edge_descriptor
            edge_descriptor;
        typedef typename boost::graph_traits< grid2d_graph<row_type,column_type,rows_num,columns_num> >::
            vertices_size_type
            vertices_size_type;
        typedef typename boost::graph_traits< grid2d_graph<row_type,column_type,rows_num,columns_num> >::
            degree_size_type
            degree_size_type;

        typedef typename boost::graph_traits< grid2d_graph<row_type,column_type,rows_num,columns_num> >::
            vertex_iterator
            vertex_iterator;
        typedef typename boost::graph_traits< grid2d_graph<row_type,column_type,rows_num,columns_num> >::
            out_edge_iterator
            out_edge_iterator;
        static const row_type ROWS_NUM=rows_num;
        static const column_type COLUMNS_NUM=columns_num;
//        template <typename ord_type>
//        static row_type init_row(ord_type r) { return static_cast<row_type>(r); }

        vertices_size_type index_of(vertex_descriptor v) const {
            return v.first+v.second*ROWS_NUM;
        }

        friend inline typename type::vertices_size_type
        get(boost::vertex_index_t,
            const type& graph,
            typename type::vertex_descriptor v)
        {
          return (graph.index_of(v));
        }

        friend inline grid_graph_index_map<
                        type,
                        typename type::vertex_descriptor,
                        typename type::vertices_size_type
        >
        get(boost::vertex_index_t, const type& graph) {
            return (grid_graph_index_map<
                    type,
                    typename type::vertex_descriptor,
                    typename type::vertices_size_type
                    >(graph));
        }
        /*
        degree_size_type
        out_degree(typename Graph::vertex_descriptor& u, const Graph&)
        {
            return 2 + (u.first==0 || u.first==Graph::ROWS_NUM-1 ? 0 : 1) +
                (u.second==0 || u.second==Graph::COLUMNS_NUM-1 ? 0 : 1);
        }
*/
    };

    struct g2dg_traversal_category :
        public virtual boost::bidirectional_graph_tag,
        public virtual boost::adjacency_graph_tag,
        public virtual boost::vertex_list_graph_tag { };

  //===================
  // Index Property Map
  //===================

  template <typename Graph,
            typename Descriptor,
            typename Index>
  struct grid_graph_index_map {
  public:
    typedef Index value_type;
    typedef Index reference_type;
    typedef reference_type reference;
    typedef Descriptor key_type;
    typedef boost::readable_property_map_tag category;

    grid_graph_index_map() { }

    grid_graph_index_map(const Graph& graph) :
      m_graph(&graph) { }

    value_type operator[](key_type key) const {
      return (m_graph->index_of(key));
    }

    friend inline Index
    get(const grid_graph_index_map<Graph, Descriptor, Index>& index_map,
        const typename grid_graph_index_map<Graph, Descriptor, Index>::key_type& key)
    {
      return (index_map[key]);
    }

  protected:
    const Graph* m_graph;
  };

    /*
    Map from vertices to indices
    *
    template <typename Graph>
    class vertex_index_map {
    public:
        typedef std::size_t value_type;
        typedef value_type reference;
        typedef typename Graph::vertex_descriptor key_type;
        typedef boost::readable_property_map_tag category;

        reference operator[]( key_type e ) const
        {
            return e.first+e.second*Graph::ROWS_NUM;
        }
    };
    template <typename Graph>
    struct vertex_index_map_traits
    {
        typedef typename boost::property_map <Graph, boost::vertex_index_t>::const_type
            const_type;
        typedef typename boost::property_traits<const_type>::reference value_type;
        typedef typename boost::property_traits<const_type>::key_type key_type;
    };*/

    /*
    Map from edges to weight values
    */
    template <typename Graph>
    class edge_weight_map {
    public:
        typedef edge_weight_map<Graph> type;
        typedef double value_type;
        typedef value_type reference;
        typedef typename boost::graph_traits<Graph>::edge_descriptor key_type;
        typedef boost::readable_property_map_tag category;

        edge_weight_map() {}

        template <typename input_iterator>
        edge_weight_map(input_iterator begin, input_iterator end) {
            for (typename Graph::row_t r=0; r < Graph::ROWS_NUM; r++)
                for (typename Graph::column_t c=0; c < Graph::COLUMNS_NUM; c++) {
                    if (begin == end) break;
                    m_mx[r][c] = *(begin++);
                }
        }

        reference operator[]( typename Graph::edge_descriptor e ) const
        {
            return m_mx[e.second.first][e.second.second];
        }

    friend inline value_type get(const type& pmap, key_type e)
    { return pmap[e]; }

    private:
        value_type m_mx[Graph::ROWS_NUM][Graph::COLUMNS_NUM];
    };

    // Use these propety_map and property_traits parameterizations to refer to
    // the associated property map types.
    template <typename Graph>
    struct edge_weight_map_traits
    {
        typedef typename boost::property_map <Graph, boost::edge_weight_t>::const_type
            const_type;
        typedef typename boost::property_traits<const_type>::reference value_type;
        typedef typename boost::property_traits<const_type>::key_type key_type;
    };

/*
    edge_weight_map_value_type get(boost::edge_weight_t tag,
                                   const ring_graph_ns::ring_graph& g,
                                   edge_weight_map_key e) {
      return get(tag, g)[e];
    }

    // This expression is not part of a graph concept, but is used to return the
    // default vertex index map used by the Dijkstra search algorithm.

    template <typename Graph>
    typename vertex_index_map_traits<Graph>::const_type
    get(boost::vertex_index_t, const Graph&) {
        return vertex_index_map_traits<Graph>::const_type();
    }*/

} // namespace g2dg

namespace boost {

  template <typename row_type, typename column_type, row_type rows_num, column_type columns_num>
  struct graph_traits< g2dg::grid2d_graph<row_type, column_type, rows_num, columns_num> > {
    typedef g2dg::vertex vertex_descriptor;
    typedef g2dg::g2dg_edge edge_descriptor;
    typedef g2dg::g2dg_traversal_category traversal_category;
    typedef g2dg::g2dg_vertex_iterator<row_type,column_type,rows_num,columns_num>
        vertex_iterator;
    typedef g2dg::g2dg_out_edge_iterator<row_type,column_type,rows_num,columns_num>
        out_edge_iterator;
    typedef unsigned int vertices_size_type;
    typedef unsigned int  degree_size_type;
    typedef undirected_tag directed_category;
    typedef disallow_parallel_edge_tag edge_parallel_category;

    // This type is not part of a graph concept, but is used to return the
    // default vertex index map used by the Dijkstra search algorithm.
    typedef vertex_descriptor vertex_property_type;

  };
#ifdef NEED_PROPERTY_MAP
// ReadablePropertyGraph associated types
    template <typename Graph>
    struct property_map <Graph, edge_weight_t>
    {
        typedef typename g2dg::edge_weight_map<Graph> type;
        typedef typename g2dg::edge_weight_map<Graph> const_type;
    };

    template <typename Graph>
    struct property_map <const Graph, edge_weight_t>
    {
        typedef typename g2dg::edge_weight_map<Graph> type;
        typedef typename g2dg::edge_weight_map<Graph> const_type;
    };
/*
    template <typename Graph>
    struct property_map <Graph, vertex_index_t>
    {
        typedef typename g2dg::vertex_index_map<Graph> type;
        typedef typename g2dg::vertex_index_map<Graph> const_type;
    };
*/
    template <typename Graph>
    struct property_map <Graph, vertex_index_t>
    {
        typedef typename g2dg::grid_graph_index_map<
            Graph,
            typename graph_traits<Graph>::vertex_descriptor,
            typename graph_traits<Graph>::vertices_size_type
            > type;
        typedef typename g2dg::grid_graph_index_map<
            Graph,
            typename graph_traits<Graph>::vertex_descriptor,
            typename graph_traits<Graph>::vertices_size_type
            > const_type;
    };
    template <typename Graph>
    struct property_map <const Graph, vertex_index_t>
    {
        typedef typename g2dg::grid_graph_index_map<
            Graph,
            typename graph_traits<Graph>::vertex_descriptor,
            typename graph_traits<Graph>::vertices_size_type
            > type;
        typedef typename g2dg::grid_graph_index_map<
            Graph,
            typename graph_traits<Graph>::vertex_descriptor,
            typename graph_traits<Graph>::vertices_size_type
            > const_type;
    };

#endif
} // namespace boost

namespace g2dg {

// PropertyMap valid expressions
template <GRID2D_GRAPH_PARAMS>
typename edge_weight_map_traits<GRID2D_GRAPH_DECLARATION>::value_type
get(typename edge_weight_map_traits<GRID2D_GRAPH_DECLARATION>::const_type pmap,
    typename edge_weight_map_traits<GRID2D_GRAPH_DECLARATION>::key_type e)
{
    return pmap[e];
}

// ReadablePropertyGraph valid expressions
template <GRID2D_GRAPH_PARAMS>
typename edge_weight_map_traits<GRID2D_GRAPH_DECLARATION>::const_type
get(boost::edge_weight_t, const GRID2D_GRAPH_DECLARATION&)
{
    return typename edge_weight_map_traits<GRID2D_GRAPH_DECLARATION>::const_type();
}

template <GRID2D_GRAPH_PARAMS>
typename edge_weight_map_traits<GRID2D_GRAPH_DECLARATION>::value_type
get(boost::edge_weight_t tag,
    const GRID2D_GRAPH_DECLARATION& g,
    typename edge_weight_map_traits<GRID2D_GRAPH_DECLARATION>::key_type e)
{
    return get(tag, g)[e];
}

template <typename Graph>
typename Graph::vertex_descriptor
source(typename Graph::edge_descriptor e, const Graph&) { return e.first; }

template <typename Graph>
typename Graph::vertex_descriptor
target(typename Graph::edge_descriptor e, const Graph&) { return e.second; }

template <typename Graph>
inline std::pair<typename Graph::vertex_iterator, typename Graph::vertex_iterator>
vertices(const Graph&) {
    return std::make_pair(
        typename Graph::vertex_iterator(0),
        typename Graph::vertex_iterator(Graph::ROWS_NUM*Graph::COLUMNS_NUM));
}

template <typename Graph>
typename Graph::vertices_size_type
num_vertices(const Graph&) {
    return Graph::ROWS_NUM*Graph::COLUMNS_NUM;
}

template <typename Graph>
inline std::pair<typename Graph::out_edge_iterator, typename Graph::out_edge_iterator>
out_edges(typename Graph::vertex_descriptor u, const Graph&)
{
    return std::make_pair(
        typename Graph::out_edge_iterator(u),
        typename Graph::out_edge_iterator(std::make_pair(u, invalid_direction)));
}

template <typename Graph>
typename Graph::degree_size_type
out_degree(typename Graph::vertex_descriptor& u, const Graph&)
{
    return 2 + (u.first==0 || u.first==Graph::ROWS_NUM-1 ? 0 : 1) +
        (u.second==0 || u.second==Graph::COLUMNS_NUM-1 ? 0 : 1);
}

} // namespace g2dg
#endif // GRID2D_GRAPH_HPP
